#pragma config(Sensor, S1,     left_light,     sensorEV3_Color)
#pragma config(Sensor, S2,     right_light,    sensorEV3_Color)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     ultrasonic,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          left_arm,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          right_motor,   tmotorEV3_Medium, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          left_motor,    tmotorEV3_Medium, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          right_arm,     tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// timer T4 is the game timer.


// the number of ms for the match
#define GAME_TIME 150000
// wheel diameter
#define WHEEL_DIAMETER 64.4
// distance between drive wheels
#define AXLE_TRACK 200

// the power level to take up slack in the drivetrain
#define BACKLASH_POWER 2
// time to activate motors to take up drive train
#define BACKLASH_TIME 100
// minimum rpm cutoff to determine a stall condition
#define STALL_MIN_RPM 5


// task to check if the motors have stalled during motion
task stall_detection()
{
	// initialize variables to save rpm
	int left_rpm = 0;
	int right_rpm = 0;

	while(true)
	{
		// simple delay to allow the motors to spin up below the cutoff
		// there might be a better way to do this
		sleep(250);

		// save motor rpms
		left_rpm = getMotorRPM(left_motor);
		right_rpm = getMotorRPM(right_motor);

		// if the motor rpms fall below a cutoff, then stall is detected
		if( left_rpm <= STALL_MIN_RPM || right_rpm <= STALL_MIN_RPM )
		{
			// stop and brake motors
			setMotorBrakeMode(left_motor, motorBrake);
			setMotorBrakeMode(right_motor, motorBrake);
			setMotorSpeed(left_motor, 0);
			setMotorSpeed(right_motor, 0);
			// play a tone to notify the operator of the stall
			//playTone(1000,100);
			playSound(soundBlip);
			// delay time for the tone to play
			sleep(250);
			break;
		}
	}
}


void drive_straight(int in_degrees)
{
	// backlash compensation
	// TODO: backlash comp current runs the wrong way...maybe
	if(in_degrees < 0)
	{
		setMotorSpeed(left_motor,-BACKLASH_POWER);
		setMotorSpeed(right_motor,-BACKLASH_POWER);
		sleep(BACKLASH_TIME);
	}
	else if (in_degrees > 0 )
	{
		setMotorSpeed(left_motor,BACKLASH_POWER);
		setMotorSpeed(right_motor,BACKLASH_POWER);
		sleep(BACKLASH_TIME);
	}
	else
	{
		setMotorBrakeMode(left_motor, motorBrake);
		setMotorBrakeMode(right_motor, motorBrake);
		setMotorSpeed(left_motor, 0);
		setMotorSpeed(right_motor, 0);
	}

	// reset motor encoders after backlash compensation
	resetMotorEncoder(left_motor);
	resetMotorEncoder(right_motor);

	// engage stall detection task
	startTask(stall_detection);
	// movement is non blocking
	// execution moves right to next action
	setMotorSyncEncoder(left_motor, right_motor, 0, in_degrees, 15);
	//
	sleep(1000);
	// after motion is complete, the stall detection is disengaged
	stopTask(stall_detection);
	// delay to allow the task to completely end
	sleep(100);
}


// dashboard to show operators remaining time and robot conditions
task dashboard()
{
	// used to convert ints to strings
	char buf[10];
	// Resets timer T1 to start counting at 0
	clearTimer(T4);
	// loops code while timer T1 has counted less than 10 seconds
	while(time1[T4] < GAME_TIME)
	{
		// clear the display
		eraseDisplay();
		// convert the remaining game time to a string stored in buf
		sprintf(buf, "%d", (( GAME_TIME - time1[T4] )/1000)   );
		// display the remaining game time
		displayCenteredBigTextLine(1, buf);
		// display the remaining game time
		displayCenteredBigTextLine(3, buf);
		//wait
		sleep(1000);
	}
}


void initialize()
{
	playSound(soundBlip);
	// all motors set to brake mode
	setMotorBrakeMode(motorA, motorBrake);
	setMotorBrakeMode(motorB, motorBrake);
	setMotorBrakeMode(motorC, motorBrake);
	setMotorBrakeMode(motorD, motorBrake);

}

task main()
{

	// initilize robot conditions
	initialize();

	// start the dashboard with lowest priority
	startTask(dashboard, 0);


	// drive straight
	drive_straight(3600);


	stopAllTasks();


}
